#!@PERL@ -I@prefix@/lib/perl

=head1 NAME

locarnate

=head1 SYNOPSIS

locarnate [-parwise_parameters <parameters> --help] <inputFile>
    
    Creates MSAs using different pairwise aligners and TCoffee as
    a multiple alignment tool

AUTHOR: Niklas Meinzer <meinzern@informatik.uni-freiburg.de

OPTIONS


        --parwise_parameters    parameters for the pairwise alignment step
        
        --help  display this help message and exit


=cut

my $prefix = "@prefix@";
my $exec_prefix = "@exec_prefix@";
my $bindir = "@bindir@";

## the tcoffe version to use
my $t_coffee = "@TCOFFEE@";

## vienna package programs
my $RNAfold = "@RNAfold@";
my $RNAalifold = "@RNAalifold@";


use strict;
use warnings;

use Pod::Usage;
use Getopt::Long;

use FileHandle;
use DirHandle;
use FindBin;

use MLocarna;
use MLocarna::PairwiseAligners;

use lib $FindBin::RealBin;

### global varibales ###
my $locarna = "$bindir/locarna";
my $base_path = 'results';
my $ribosum_file = "$prefix/share/locarna/Matrices/RIBOSUM85_60";

###########################################################################
# main                                                                    
###########################################################################

### options ###

my $version = '0.9';
my $description = 'Calculates a multiple local RNA sequence structure'
    .' alignment of the sequences given by INPUT';

# all options are collected in the options hash
my %options;
$options{"BP-Probability-Calculator"} = "locarna_rnafold_pp";
$options{TCoffee} = "t_coffee";
$options{Locarna} = $bindir . "/locarna";

$options{tcoffee_params} = "";
$options{pairwise_aligner_parameter} = "";
$options{pp_calculator_params} = "";

GetOptions("help!" => \$options{help},
           "pairwise_parameters=s" => \$options{pairwise_aligner_parameter},
           "tcoffee_parameters=s" => \$options{tcoffee_params},
           "pp_preprocessing_parameters=s" => \$options{pp_preprocessing_params},
           );

pod2usage() if ($options{help});

### calculations ###

# check pairwise aligner parameters
my $checkresult = check_locarna_params(\%options, $options{pairwise_aligner_parameter});
if ($checkresult ne "") {
    print "Locarna parameters invalid. Locarna says: " . $checkresult . "\n";
    exit(1);
}

# check t_coffe parameters
$checkresult = check_tcoffee_params(\%options, $options{tcoffee_params});
if ($checkresult ne "") {
    print "Tcoffee parameters invalid. Tcoffee says: " . $checkresult . "\n";
    exit(1);
}
# check locarna_rnafold_pp parameters
$checkresult = check_pp_parameters(\%options, $options{pp_preprocessing_params});
if ($checkresult ne "") {
    print "Locarna_rnafold_pp parameters invalid. Locarna_rnafold_pp says: " . $checkresult . "\n";
    exit(1);
}
my $results_path = "test_results";
mkdir($results_path);
pod2usage("Not enough arguments!\n") if scalar(@ARGV) < 1;
my $sequences = MLocarna::read_fasta($ARGV[scalar(@ARGV) - 1]);


calculate_basepair_probabilities(\%options, $results_path, $sequences);

mkdir($results_path."/pair");

my $pair_alignments =
  MLocarna::PairwiseAligners::locarna_compute_pairwise_alignments(
    \%options, $results_path, $sequences, $bindir);

my $libfile = ($results_path . "/input.lib");

MLocarna::write_tcoffee_lib_file($libfile, $pair_alignments);

calculate_mult_alignment(\%options, $results_path, $libfile);
                           
#~ 
#~ my $mult_alignment = parse_mult_alignment($options, $results_path, 
                                          #~ $sequences);
#~ 
#~ my $cons_rates = determine_cons_rates($options, $sequences, 
                                      #~ $pair_alignments, $mult_alignment);
#~ # \@cons_rates
#~ # []  $column_rate
#~ 
#~ # determine_exclusions($options, $sequences, $pair_alignments, 
#~ #                      $mult_alignment, $cons_rates);
#~ 
#~ calculate_cons_data($options, $results_path, 
                    #~ $mult_alignment, $cons_rates);
#~ 
#~ my $cons_data = parse_cons_data($options, $results_path, $cons_rates);
#~ # \%cons_data
#~ # {'seq'}    $seq
#~ # {'struc'}  $struc
#~ 
#~ # join_exclusions($options, $sequences, $mult_alignment, 
#~ #                 $cons_rates, $cons_data);
#~ 
#~ write_clustal($options, $results_path, $sequences, 
              #~ $mult_alignment, $cons_rates);
#~ write_fasta($options, $results_path, $sequences, 
            #~ $mult_alignment, $cons_rates);
#~ 
#~ write_stockholm($options, $results_path, $sequences, 
                #~ $mult_alignment, $cons_rates, $cons_data);
#~ 
#~ write_flat($options, $results_path, $sequences, 
           #~ $mult_alignment, $cons_rates, $cons_data);
#~ 
#~ cleanup($options, $results_path, $sequences);


###########################################################################
# subs                                                                    
###########################################################################

# calculates the pairwise base pair probabilities for all input sequences using RNAfold
sub calculate_basepair_probabilities {

  my $options =  $_[0];
  my $results_path = $_[1];
  my $sequences = $_[2];

  *STDERR->print('Calculate pair probabilities...'."\r");

  mkdir($results_path.'/dp');

  my $pp_tool_call = $bindir . "/" . $options->{"BP-Probability-Calculator"};

  for (my $i = 0; $i < scalar(@{$sequences}); ++$i) {
    my $tag = '>S'.($i + 1);

    # the filename of the pp file
    my $pp_file = $results_path . "/dp/S" . ($i + 1) . ".pp";
    
    my $sequence = $sequences->[$i]->{seq};

    # open pipe to pp tool
    open (my $PIPE, "|$pp_tool_call -o $pp_file");
    print $PIPE $tag . "\n" . $sequence . "\n";
    close($PIPE);
  }

  *STDERR->print('Calculate pair probabilities... done!'."\n");
}



sub calculate_pairwise_alignments {
  if (@_ != 3) {
    locarnate::Error::debug('Wrong argument number');
  }

  my $options =  $_[0];
  my $results_path = $_[1];
  my $sequences = $_[2];

  my $numSequences = scalar(@{$sequences});

  my $parameter = ' ';

  my $counter = 0;
  # how many pairwise alignments must be calculated?
  my $number = $numSequences * 
      ($numSequences - 1) / 2;

  for (my $i = 0; $i < $numSequences - 1; ++$i) {
    # the path to the dotplot of the this sequence
    my $first = $results_path.'/dp/S'.($i + 1) .= '.pp';

    # iterate over all other sequences in the rest of the array and compute
    # pairwise alignment
    for (my $j = $i + 1; $j < $numSequences; ++$j) {
      ++$counter;
      *STDERR->print("\r".(' 'x80));
      *STDERR->print("\r".'Calculate pairwise alignment '.
                     $counter.'/'.$number.' (Seq '.($i + 1).' <-> Seq '.
                     ($j + 1).')...');
      # path to the dot plot of the other sequence
      my $second = $results_path.'/dp/S'.($j + 1) . '.pp';

      # path to the output file
      my $result = $results_path.'/pair/S'.($i + 1).'_S'.($j + 1).'.aln';

      # assemble the call to locarna
      my $call = $bindir .'/locarna '.$parameter.
          ' --clustal='.$result.' --write-structure '
          .$first.' '.$second.' 1>/dev/null 2>/dev/null';

      my $code = system($call);
      if ($code) {
        # first locarna version had no parameter --write-structure
        my $call = $bindir .'/locarna '.$parameter.
            ' --clustal='.$result.' '
            .$first.' '.$second.' 1>/dev/null 2>/dev/null';

        my $code = system($call);
        if ($code) {
          print('Can\'t perform locARNA calculation'.
                            " (developed under locarna 1.7.8, call:\n".$call.")\n");
        }
      }
    }
  }
  *STDERR->print(' done!'."\n");
}

sub parse_pair_alignments {

  my $options =  $_[0];
  my $results_path = $_[1];
  my $sequences = $_[2];
  my $numSequences = scalar(@{$sequences});

  *STDERR->print('parse pairwise alignments...'."\r");

  my @alignments = ();

  for (my $i = 0; $i < $numSequences - 1; ++$i) {
    for (my $j = $i + 1; $j < $numSequences; ++$j) {
      my $file_name = $results_path.'/pair/S'.($i + 1).
          '_S'.($j + 1).'.aln';
          
      my ($header, $aln) = MLocarna::read_clustalw_aln($file_name);
      my $score;
      if ($header =~ m/Score: ([\d|-]+)/) {
        $score = $1;
      }
      push(@alignments, {"rows" => $aln, "score" => $score});
    }
  }

  *STDERR->print('Parse pairwise alignments... done!'."\n");

  return(\@alignments);
}

sub calculate_mult_alignment {
  my ($options, $results_path, $libFile) = @_;
  
  mkdir($results_path.'/mult');

  *STDERR->print('Calculate multiple alignment...'."\r");


  my $aln_file_name = $results_path.'/mult/tcoffee.aln';
  my $out_file_name = $results_path.'/mult/tcoffee.out';
  my $err_file_name = $results_path.'/mult/tcoffee.err';

  my $call = $options->{TCoffee} . " " . $options->{tcoffee_params} . ' -in=L'.$libFile.
      ' -outfile='.$aln_file_name.' 1>'.$out_file_name.
      ' 2>'.$err_file_name;

  print "\n$call\n";

  my $code = system($call);

  *STDERR->print('Calculate multiple alignment... done!'."\n");
} 


sub check_locarna_params {
    # Runs Locarna without input file, but with all given parameters
    # if locarna complains that there is no input file, all other
    # parameters are ok
    # otherwise the incorrect parameters are returned
    my ($options, $parameters) = @_;
    
    my $call = $options->{Locarna} . " $parameters 2>&1";
    
    my @output = `$call`;

    if ($output[0] =~ /Mandatory option and\/or argument missing: <file 1>/) {
        return "";
    }
    my $error = $output[0];

    # try to remove the binary path from the error message
    my @errorsplit = split /:/, $error;
    if (scalar(@errorsplit) > 1) {
        $error = $errorsplit[1];
    }
    chomp $error;
    return $error;
}

sub check_tcoffee_params {
    # Runs Locarna without input file, but with all given parameters
    # if locarna complains that there is no input file, all other
    # parameters are ok
    # otherwise the incorrect parameters are returned
    my ($options, $parameters) = @_;
    
    my $call = $options->{TCoffee} . " $parameters 2>&1";
    
    my @output = `$call`;

    foreach my $line (@output) {
        if( $line =~ /needs a value/ or $line =~ /IS NOT A PARAMETER/) {
            chomp $line;
            return $line;
        }
    }
    return "";
}

sub check_pp_parameters {
    # Runs locarna_rnafol_pp without input file, but with all given parameters
    # and checks if it complains
    my ($options, $parameters) = @_;
    
    my $call = $bindir . "/" .$options->{"BP-Probability-Calculator"} . " $parameters 2>&1";
    
    my @output = `$call hopefully_this_file_does_not_exist.pdf.txt`;

    my $error =  $output[0];

    if ($error =~ /Error in input format/) {
        return "";
    }

    # try to remove bin path
    
    # try to remove the binary path from the error message
    my @errorsplit = split /:/, $error;
    if (scalar(@errorsplit) > 1) {
        $error = $errorsplit[1];
    }
    chomp $error;
    return $error;   
}
