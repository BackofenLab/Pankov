#!@PERL@ -I@prefix@/lib/perl

=head1 NAME

locarnate

=head1 SYNOPSIS

locarnate [-parwise_parameters <parameters> --help] <inputFile>
    
    Creates MSAs using different pairwise aligners and TCoffee as
    a multiple alignment tool

AUTHOR: Niklas Meinzer <meinzern@informatik.uni-freiburg.de

OPTIONS


        --parwise_parameters    parameters for the pairwise alignment step
        
        --help  display this help message and exit


=cut

my $prefix = "@prefix@";
my $exec_prefix = "@exec_prefix@";
my $bindir = "@bindir@";

## the tcoffe version to use
my $t_coffee = "@TCOFFEE@";

## vienna package programs
my $RNAfold = "@RNAfold@";
my $RNAalifold = "@RNAalifold@";


use strict;
use warnings;

use Pod::Usage;
use Getopt::Long;

use FileHandle;
use DirHandle;
use FindBin;

use MLocarna;
use MLocarna::PairwiseAligners;

use lib $FindBin::RealBin;

### global varibales ###
my $locarna = "$bindir/locarna";
my $base_path = 'results';
my $ribosum_file = "$prefix/share/locarna/Matrices/RIBOSUM85_60";

###########################################################################
# main                                                                    
###########################################################################

### options ###

my $version = '0.9';
my $description = 'Calculates a multiple local RNA sequence structure'
    .' alignment of the sequences given by INPUT';

# all options are collected in the options hash
my %options;
$options{RNAfold} = "RNAfold";
$options{TCoffee} = "t_coffee";


GetOptions("help!" => \$options{help},
           "pairwise_parameters=s" => \$options{pairwise_aligner_parameter});

pod2usage() if ($options{help});

### calculations ###

my $results_path = "test_results";
mkdir($results_path);
pod2usage("Not enought arguments!\n") if scalar(@ARGV) < 1;
my $sequences = MLocarna::read_fasta($ARGV[scalar(@ARGV) - 1]);


calculate_basepair_probabilities(\%options, $results_path, $sequences);

my $pair_alignments =
  MLocarna::PairwiseAligners::locarna_compute_pairwise_alignments(
    \%options, $results_path, $sequences, $bindir);

my $libfile = ($results_path . "/input.lib");

print "libfile = $libfile\n";

MLocarna::write_tcoffee_lib_file($libfile, $pair_alignments);

calculate_mult_alignment(\%options, $results_path, $libfile);
                           
#~ 
#~ my $mult_alignment = parse_mult_alignment($options, $results_path, 
                                          #~ $sequences);
#~ 
#~ my $cons_rates = determine_cons_rates($options, $sequences, 
                                      #~ $pair_alignments, $mult_alignment);
#~ # \@cons_rates
#~ # []  $column_rate
#~ 
#~ # determine_exclusions($options, $sequences, $pair_alignments, 
#~ #                      $mult_alignment, $cons_rates);
#~ 
#~ calculate_cons_data($options, $results_path, 
                    #~ $mult_alignment, $cons_rates);
#~ 
#~ my $cons_data = parse_cons_data($options, $results_path, $cons_rates);
#~ # \%cons_data
#~ # {'seq'}    $seq
#~ # {'struc'}  $struc
#~ 
#~ # join_exclusions($options, $sequences, $mult_alignment, 
#~ #                 $cons_rates, $cons_data);
#~ 
#~ write_clustal($options, $results_path, $sequences, 
              #~ $mult_alignment, $cons_rates);
#~ write_fasta($options, $results_path, $sequences, 
            #~ $mult_alignment, $cons_rates);
#~ 
#~ write_stockholm($options, $results_path, $sequences, 
                #~ $mult_alignment, $cons_rates, $cons_data);
#~ 
#~ write_flat($options, $results_path, $sequences, 
           #~ $mult_alignment, $cons_rates, $cons_data);
#~ 
#~ cleanup($options, $results_path, $sequences);


###########################################################################
# subs                                                                    
###########################################################################

# calculates the pairwise base pair probabilities for all input sequences using RNAfold
sub calculate_basepair_probabilities {

  my $options =  $_[0];
  my $results_path = $_[1];
  my $sequences = $_[2];

  *STDERR->print('Calculate pair probabilities...'."\r");

  mkdir($results_path.'/dp');

  # write fasta file
  my $file_name = $results_path.'/dp/input.fa';
  open(my $file , ">" . $file_name);

  for (my $i = 0; $i < scalar(@{$sequences}); ++$i) {
    my $tag = '>S'.($i + 1);
    $file->print($tag."\n");
    my $sequence = $sequences->[$i]->{seq};
    print $file ($sequence."\n");
    
  }
  close $file;


  # call RNAfold
  chdir($results_path.'/dp');
  
  my $call = $options->{RNAfold};

  $call .= ' -p < input.fa 1>/dev/null';
  my $code = system($call);

  # parse the dot plots
  for (my $i = 0; $i < scalar(@{$sequences}); ++$i) {
    my ($s, $prob) = MLocarna::read_dp_ps("S" . ($i+1) . "_dp.ps");
    # add pairwise probabilities to the sequence
    $sequences->[$i]->{pairProbs} = $prob;
  }

  chdir($prefix);
  *STDERR->print('Calculate pair probabilities... done!'."\n");
}



sub calculate_pairwise_alignments {
  if (@_ != 3) {
    locarnate::Error::debug('Wrong argument number');
  }

  my $options =  $_[0];
  my $results_path = $_[1];
  my $sequences = $_[2];

  my $numSequences = scalar(@{$sequences});

  my $parameter = ' ';

  my $counter = 0;
  # how many pairwise alignments must be calculated?
  my $number = $numSequences * 
      ($numSequences - 1) / 2;

  for (my $i = 0; $i < $numSequences - 1; ++$i) {
    # the path to the dotplot of the this sequence
    my $first = $results_path.'/dp/S'.($i + 1) .= '_dp.ps';

    # iterate over all other sequences in the rest of the array and compute
    # pairwise alignment
    for (my $j = $i + 1; $j < $numSequences; ++$j) {
      ++$counter;
      *STDERR->print("\r".(' 'x80));
      *STDERR->print("\r".'Calculate pairwise alignment '.
                     $counter.'/'.$number.' (Seq '.($i + 1).' <-> Seq '.
                     ($j + 1).')...');
      # path to the dot plot of the other sequence
      my $second = $results_path.'/dp/S'.($j + 1) . '_dp.ps';

      # path to the output file
      my $result = $results_path.'/pair/S'.($i + 1).'_S'.($j + 1).'.aln';

      # assemble the call to locarna
      my $call = $bindir .'/locarna '.$parameter.
          ' --clustal='.$result.' --write-structure '
          .$first.' '.$second.' 1>/dev/null 2>/dev/null';

      my $code = system($call);
      if ($code) {
        # first locarna version had no parameter --write-structure
        my $call = $bindir .'/locarna '.$parameter.
            ' --clustal='.$result.' '
            .$first.' '.$second.' 1>/dev/null 2>/dev/null';

        my $code = system($call);
        if ($code) {
          print('Can\'t perform locARNA calculation'.
                            " (developed under locarna 1.4.5, call:\n".$call.')');
        }
      }
    }
  }
  *STDERR->print(' done!'."\n");
}

sub parse_pair_alignments {

  my $options =  $_[0];
  my $results_path = $_[1];
  my $sequences = $_[2];
  my $numSequences = scalar(@{$sequences});

  *STDERR->print('parse pairwise alignments...'."\r");

  my @alignments = ();

  for (my $i = 0; $i < $numSequences - 1; ++$i) {
    for (my $j = $i + 1; $j < $numSequences; ++$j) {
      my $file_name = $results_path.'/pair/S'.($i + 1).
          '_S'.($j + 1).'.aln';
          
      my ($header, $aln) = MLocarna::read_clustalw_aln($file_name);
      my $score;
      if ($header =~ m/Score: ([\d|-]+)/) {
        $score = $1;
      }
      push(@alignments, {"rows" => $aln, "score" => $score});
    }
  }

  *STDERR->print('Parse pairwise alignments... done!'."\n");

  return(\@alignments);
}

sub calculate_mult_alignment {
  my ($options, $results_path, $libFile) = @_;
  
  mkdir($results_path.'/mult');

  *STDERR->print('Calculate multiple alignment...'."\r");


  my $aln_file_name = $results_path.'/mult/tcoffee.aln';
  my $out_file_name = $results_path.'/mult/tcoffee.out';
  my $err_file_name = $results_path.'/mult/tcoffee.err';

  my $call = $options->{TCoffee}.' -in=L'.$libFile.
      ' -outfile='.$aln_file_name.' 1>'.$out_file_name.
      ' 2>'.$err_file_name;

  print "\n$call\n";

  my $code = system($call);

  *STDERR->print('Calculate multiple alignment... done!'."\n");
} 

