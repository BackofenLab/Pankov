#ifndef BASEPAIRS_LOOPTRAVERSAL_HH
#define BASEPAIRS_LOOPTRAVERSAL_HH

#include <list>
#include <queue>

#include "basepairs.hh"

//! triple stores three values first, second, third.
//! extension of std::pair to 3-tuple
template<class T1,class T2,class T3>
class triple: public std::pair<T1,T2> {
public:
    T3 third;

    triple(const T1 &x1,const T2 &x2,const T3 &x3): std::pair<T1,T2>(x1,x2),third(x3) {
    }
};


//! quadruple stores four values first, second, third, fourth.
//! extension of triple to 4-tuple
template<class T1,class T2,class T3,class T4>
class quadruple: public triple<T1,T2,T3> {
public:
    T4 fourth;

    quadruple(const T1 &x1,const T2 &x2,const T3 &x3,const T4 &x4): triple<T1,T2,T3>(x1,x2,x3),fourth(x4) {
    }
};



// ============================================================
// class BasePairsLoopTraversal
/** provides functionality for loop traversal that is used for exact matching
    
    The class will offer traversal of loops that have suboptimal loop
    length up to a given delta. The idea is that small loop length is
    usually beneficial for the RNA energy.

    We dropped a former idea of traversing all maximal loops, that is
    loops that result from a maximally extended non-crossing subset of
    all base pairs that are enclosed by the respective loop closing
    base pair. Albeit this may also guarantee certain complexity
    bounds during evaluation of the recursion equation, this may be
    not what we want and enumeration of maximal loops is very
    expensive.

    
    For the traversal the class allows to iterate over edges in the
    loop, sorted by end positions as it is required for evaluating the
    recursion equation. Iteration will be possible from left to right
    and from right to left. (We may offer traversal sorted by start
    positions, as this is required for more efficient parallel
    matching into the loop as far as exact match is possible.)  For
    traversal, the class offers support stl-style const_iterators with
    begin and end functions.
    
    
*/

class BasePairsLoopTraversal {

    size_type delta; //!< suboptimality level
    
    const BasePairs &bps;
    
public:
    typedef size_t size_type;

    //! construct from set of all base pairs and delta
    BasePairsLoopTraversal(const BasePairs &bps_, size_type delta)
	: bps(bps_),
	  Delta(delta_)
    {
	precompute_all_loops();
    }
    

    
    
    //! const iterator over loop edges
    class const_iterator {
    public:
	size_type
	from_index() const;
	size_type
	to_index() const;
	size_type
	from_pos() const;
	size_type
	to_pos() const;
    };
 
    
private:
    
    

    //! tuple of current position, constraint list index, and the index of left position's
    //! entry
    typedef triple<size_type, size_type, size_type> pqueue_entry_t;
    
    //! function class for comparison of two entries in the priority queue
    class compare_pqueue_entry {
    public:
	//! \returns false, if x<y.  Define that a pqueue entry is
	//! smaller if its position is larger!  We want to get
	//! leftmost entries first. In case of several entries with
	//! the same position, we want the one with leftmost origin
	//! (such that "allowed" case comes last). We assume that
	//! smaller index means less or equal position, since we
	//! compare origin indices instead of positions).
	bool
	operator ()(const pqueue_entry_t &x, const pqueue_entry_t &y) const {
	    return x.first > y.first || (x.first==y.first && x.third>y.third);
	}
    };
	

    typedef std::priority_queue<pqueue_entry_t,std::vector<pqueue_entry_t>, compare_pqueue_entry> pqueue_t;
    
    typedef std::vector<size_type> arcidxvec_t;
    

    //! a instruction is a list of pairs (target index, source index)
    //! the indices are indices of the (to be constructed) DP table.
    //! IDEA: table entries will be computed in this order, a second
    //! table associates indices to positions.  this will allow
    //! traversing the list of instructions for computing all necessary
    //! entries for evaluating all maximal loops
    typedef std::pair<size_type,size_type> instruction_t;
    
    //! type for vector that associates table indices to positions
    typedef std::vector<size_type> idx2pos_vec_t;
    

<<<<<<< basepairs_looptraversal.hh
=======
    //! table for storing for each arc a vector of arcs that are right
    //! of it and cross this arc
    std::vector<arcidxvec_t> right_crossing_arcs_tab;
    
    constraint_lists_vec_t constraint_lists_tab; //!< table of the constraint lists
    
    //! Conceptually, last_loop_index[constraint_index] is the table
    //! index of the last entry for the constraint with index
    //! constraint_index. The table index points to the last position
    //! where we used this constraint set. The position allows
    //! checking whether we can merge.  (We can merge, if the
    //! constraint set was already accessed for the current position.)
    //! In addition to the set of constraint arcs, a second component
    //! of the "state" is whether arcs to the right are allowed or not.
    //! We store the index for allowed in last_loop_index[constraint_index].first and
    //! the index for disallowed in last_loop_index[constraint_index].second.
    //! When there is no need to distinguish the states, both indices can be the same.
    std::vector< std::pair<size_type,size_type> > last_loop_index;
    
    
    //! has some constraint the right end x?
    bool some_constraint_has_right_end(size_type x,const constraint_list_t &constraints) const;


    // ATTENTION: not all optional arcs are necessarily constraints!
    // for some optional arcs, satisfaction of the constraint is
    // already guaranteed!  The left to right strategy does not
    // guarantee minimality. Better (minimal?) results are obtained
    // by merging of left->right and right->left. How???
    

    //! test, whether the arc is subsumed by the constraints.  An arc
    //! is subsumed if choosing this arc will disallow to satisfy all
    //! constraints.  ATTENTION: current implementation is not correct
    bool
    is_subsumed_basepair(const Arc &outer_arc, const Arc &arc, const constraint_list_t &constraints);
    
    //! test, whether an arc is optional given the constraints
    //! \param outer_arc the outer arc that encloses the loops
    //! \param arc the arc that is tested
    //! \param constraints is the list of arcs that are explicitly deleted in the current path
    //! 
    //! An arc is optional iff it is possible to cross all arcs in the constraint set and
    //! the arc itself with base pairs right of the arc at the same time.
    //! ATTENTION: current implementation is not correct
    bool
    is_optional_basepair(const Arc &outer_arc, const Arc &arc, const constraint_list_t &constraints);
    
    //! @returns list of arcs that cross given arc from the right, asc lex sorted by (left end, right end)
    const arcidxvec_t &right_crossing_arcs(const Arc &arc) {
	return right_crossing_arcs_tab[arc.idx()];
    }
>>>>>>> 1.12
    
    
    //!precompute loops for all base pairs
    void
    precompute_all_loops();
    
    //!precompute loops for all base pairs
    void
    precompute_loops(const Arc &arc);
    
};

#endif // BASEPAIRS_LOOPTRAVERSAL_HH
